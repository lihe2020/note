### 1. ReentrantLock可重入锁

#### 1.1 与synchronized对比

参见《02、锁（a）synchronized》的2.3小节。

#### 1.2 公平 VS 非公平

公平与非公平是针对获取锁而言，公平锁会按照请求锁的时间一次获得锁，也就是FIFO。而非公平锁是简单粗暴的使用CAS获取锁，获取失败的情况下才退化成公平锁。

ReentrantLock默认是非公平锁，通常非公平锁的性能会比公平锁好。非公平锁可能会使线程“饥饿”，但是在高并发的情况下，相对于公平锁的冗长入队、阻塞、唤醒流程来说，非公平锁如果一次能成功地获取到锁，那么可以大大的降低线程上下文切换开销。

《Java并发编程的艺术》这本书中提到，二者上下文切换次数差距高达133倍。

> 面试重点。

#### 1.3 源码解析
源码冗长而且不能体现出锁获取和释放流程，与其放在这里占位置不如移除掉。

### 2. ReentrantReadWriteLock可重入的读写锁

读写锁（RRW）适用于读多写少的场景，例如内存缓存， RRW 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁，一个是用于读操作的 ReadLock，一个是用于写操作的 WriteLock。

RRW 也是基于 AQS 实现的，它的自定义同步器（继承 AQS）需要在同步状态 state 上维护多个读线程和一个写线程的状态，该状态的设计成为实现读写锁的关键。RRW 很好地使用了高低位，来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，**高 16 位表示读，低 16 位表示写**。一个线程尝试获取写锁时，会先判断同步状态 state 是否为 0。如果 state 等于 0，说明暂时没有其它线程获取锁；如果 state 不等于 0，则说明有其它线程获取了锁。

一个线程尝试获取写锁时，会先判断同步状态 state 是否为 0。如果 state 等于 0，说明暂时没有其它线程获取锁；如果 state 不等于 0，则说明有其它线程获取了锁。此时再判断同步状态 state 的低 16 位（w）是否为 0，如果 w 为 0，则说明其它线程获取了读锁，此时进入 CLH 队列进行阻塞等待；如果 w 不为 0，则说明其它线程获取了写锁，此时要判断获取了写锁的是不是当前线程，若不是就进入 CLH 队列进行阻塞等待；若是，就应该判断当前线程获取写锁是否超过了最大次数，若超过，抛异常，反之更新同步状态。

一个线程尝试获取读锁时，同样会先判断同步状态 state 是否为 0。如果 state 等于 0，说明暂时没有其它线程获取锁，此时判断是否需要阻塞，如果需要阻塞，则进入 CLH 队列进行阻塞等待；如果不需要阻塞，则 CAS 更新同步状态为读状态。如果 state 不等于 0，会判断同步状态低 16 位，如果存在写锁，则获取读锁失败，进入 CLH 阻塞队列；反之，判断当前线程是否应该被阻塞，如果不应该阻塞则尝试 CAS 同步状态，获取成功更新同步锁为读状态。

### 3. 读写锁再优化之 StampedLock

RRW 被很好地应用在了读大于写的并发场景中，然而 RRW 在性能上还有可提升的空间。**在读取很多、写入很少的情况下，RRW 会使写入线程遭遇饥饿（Starvation）问题，也就是说写入线程会因迟迟无法竞争到锁而一直处于等待状态。**

在 JDK1.8 中，Java 提供了 StampedLock 类解决了这个问题。StampedLock 不是基于 AQS 实现的，但实现的原理和 AQS 是一样的，都是基于队列和锁状态实现的。与 RRW 不一样的是，StampedLock 控制锁有三种模式: 写、悲观读以及乐观读，并且 StampedLock 在获取锁时会返回一个票据 stamp，获取的 stamp 除了在释放锁时需要校验，在乐观读模式下，stamp 还会作为读取共享资源后的二次校验，后面我会讲解 stamp 的工作原理。

### 4. 参考

- https://time.geekbang.org/column/article/101244
- https://time.geekbang.org/column/article/101651