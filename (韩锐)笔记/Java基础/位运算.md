在Java的源码中，有很多与位运算有关的代码，而实际工作中很少有机会用到，所以有些看起来晦涩难懂，而有些让人拍案叫绝，在此集中记录和收藏。

#### 1. 与运算(&)

相同的位均为1，结果才为1：
```java
0 & 0 ==0
0 & 1 ==0
1 & 0 ==0
1 & 1 ==1
```

#### 2. 或运算(|)
相同的位中，至少一个为1，结果就为1：
```java
0 | 0 == 0
0 | 1 == 1
1 | 0 == 1
1 | 1 == 1
```

#### 2. 异或运算(^)

相同的位必须不同，结果才位1：


```java
0 ^ 0 == 0
0 ^ 1 == 1
1 ^ 0 == 1
1 ^ 1 == 0
```

#### 3. 取反运算(~)

将0变成1，将1变成0：

```java
~0=1;
~1=0;
```

#### 4. 左移运算(<<)

将数字的二进制每一位向左移动，左边移出的部分丢弃，右边不足的部分补零。

```java
2<<1 == 4
10 <<1 ==20
```

#### 5. 右移运算(>>)

将数字的二进制每一位向右移动，右边移出的部分丢弃，左边不足的部分分情况补充：

- 正数补0
- 负数补1

```java
4 >> 2 == 1
// -14的二进制表示：1111 0010  
// -4的二进制表示：1111 1100
((byte)-14) >> 2 == -4
```

#### 6. 无符号右移运算(>>>)

将数字的二进制每一位向右移动，右边移出的部分丢弃，左边不足的部分统一补0。

```java
((byte)-14) >>> 2 == 1073741820
```

#### 7. Java中的API

##### 7.1 将int类型转换成二进制表示法

```java
Integer.toBinaryString(123)
```

##### 7.2 无符号类型转换

java中所有的数值类型都是有符号的，对于这些类型之间的转换，特别是负数，通常需要考虑二进制表示，否则转换的结果可能和你的预期不一致：

```java
// 对应的二进制：11111111
byte b = -1;
// 正常情况下的类型转换会考虑到符号位
// 也就是b本身表示的是哪个数字，结果也是相应的数字
// 这里输出结果为1
int n = b
// 不考虑符号位，相当于直接从二进制层面进行类型转换
// 输出结果为255
Byte.toUnsignedInt(b)
```

##### 7.3 获取大于或等于指定数字的最小2次幂

比如，与1相近的最小2次幂是1本身，3临近的是4，7临近的是8...
``` java
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```
这个算法的主要思路就是：从**高位到低位**，逐渐将每一位改成1，然后将得出的结果加一。

至于为什么先将cap减1，最后再加1，是为了避免当cap是2次幂本身时导致最后的结果cap的2倍，而不是cap本身。
