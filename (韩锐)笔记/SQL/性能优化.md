### 1. 最佳实践

#### 1.1 字段类型应该设为非null

null字段会让索引、索引统计和索引查找比较复杂，而且索引记录需要额外的一个字节记录null。

#### 1.2 varchar的长度设置越小越好

varchar是可变类型，它需要额外的1或2个字节记录数据长度。当设置的长度是255及以下时使用1个字节，否则2个。

varchar的长度应该尽量小，否则将会消耗较多的内存。因为MySQL会以固定大小的内存来保存varchar的值，而且当需要临时表进行排序时占用的内存将特别糟糕。

#### 1.3 适当使用冗余字段和缓存表（计数器表）

比如，Count(*)对于大数据量的查询非常影响性能，这时候就可以使用计数器表来维护表的总记录数。当然这种情况下存在并发更新的情况，为此就需要多行来分担并发锁带来的性能问题。

而对于新闻记录的评论数等也可以使用冗余字段来避免临时count(*)。

### 2. 建立合适的索引

#### 2.1 索引的三大特点

- 大大减少扫描的数据量，因为索引支持范围查找
- 不需要额外的排序和临时表，因为索引是有序的
- 将随机IO转换从顺序IO

创建索引时，选择性（不重复的索引值）越高的列应该放到最前面，这样查询的效率越高。

#### 2.2 聚集索引

聚集索引也叫唯一索引，聚集索引的数据多样性为1。非聚集索引的叶子节点存储的是指向聚集索引的指针，这样做是为了减少页分裂、页合并时二级索引的维护工作。

主键最好使用自增列，像UUID等会使得数据的插入变得完全随机，也就是产生随机IO，很有可能导致页分裂、业合并，产生较大的索引碎片。而自增列会是顺序插入，以追加的形式插入，相对来说性能好很多。

#### 2.3 覆盖索引

一个索引包含了查询需要的所有字段，叫做覆盖索引，覆盖索引避免了回表操作。当查询使用的是覆盖索引，那么explain的extra列将显示“Using index”。

**回表会导致随机IO。**

#### 2.4 排序是如何利用索引的

排序的列需要满足最左前缀原则，或者前导列为常量：

```mysql
-- 索引 idx_r (rental_date, inventory_id, customer_id)

-- 可以正常的使用索引
where rental_date='2020-08-08' order by inventory_id, customer_id;
where rental_date>'2020-08-08' order by inventory_id desc;
```

#### 2.5 更新索引统计信息

查看索引基数

```mysql
show index from [table-name]
```

修复碎片

```mysql
optimize table xxx
```

### 3. 合理的设计查询

#### 3.1 查询的数据量太大

- 有些查询查的数据量非常大，比如十万数据以上
- 使用了`select *`取出了全部的列
- 没有使用缓存（应用层）

#### 3.2 扫描行数

扫描的行数是否超出了预期？理想情况下，扫描的行数应该和返回的行数一致，不过通常很难做到这一点。explain语句的`type`列反应访问类型。

#### 3.3 优化查询语句本身

- 切分查询，比如一个删除10万行记录的delete语句将可能会导致表级锁，事务处理事件很长，占用资源过长等，为此需要将delete语句拆分成更细的粒度
- 分解关联查询

#### 3.4 查询优化器的局限性

- `xxx in (select ...)`这种子查询性能很糟糕，mysql也没有过多的优化，改成`exists`会好很多
- 