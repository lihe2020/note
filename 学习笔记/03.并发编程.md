# 并发编程入门教程

## 一  并发编程基础

### 1. 并发编程简介

**并发编程的特征**: ① 原子性，②可见性，③有序性。

---

### 2. 操作系统的并发

**最简单的CPU核心通过缓存与主存进程进行通讯模型**

<img src="http://img.mukewang.com/wiki/5efc3cd809bf95de07000298.jpg" style="zoom:50%;" />

**操作系统给，进程，线程之间的联系和区别**

<img src="http://img.mukewang.com/wiki/5efc3cf1093ad6c707000253.jpg" style="zoom:80%;" />

**进程**：是系统进行资源分配和调度的基本单位，是操作系统结构的基础。其实就是CPU时间片的切换。（类似一个产品生产的车间）

**线程**：线程是操作系统能够进行资源调度的最小单位，他被包含在进程之中，是进程中的实际运作单位，每个线程执行的都是进程代码的某个片段，特定的线程总是在执行特定的任务。

**线程与进程的区别**：

* **诞生起源**：现有进程，后有线程。
* **概念**：进程是资源分配的最小单位，线程是程序执行的最小单位
* **内存共享**：默认情况下，进程的内存无法与其他进程共享，线程共享有操作系统跟配给其父进程的内存块。

**串行，并行与并发**

* **串行**：顺序执行，按部就班。
* **并行**：同时执行，多管齐下。
* **并发**：交替执行，减少等待。

---

### 3. Java线程内存模型

**==Java线程内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存,线程的工作内存中保存了该线程所使用到的变量(该变量是从主内存中拷贝而来)。线程对变量的操作(读取,赋值)都必须在工作内存中进行。不同线程直接也无法直接访问对方工作内存中的变量,线程间变量值的传递组要通过主内存来完成==**

Java内存模型（即Java Memory Model，简称 JMM ，一种抽象的概念，并不是真是存在，他描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式（包括实例字段，静态字段和构成数组对象的元素）。

**Java线程的私有内存和主内存**：

<img src="http://img.mukewang.com/wiki/5efc8887097f2fbc07000226.jpg" style="zoom:80%;" />

**工作内存（私有）**：JVM运行程序的实体是线程，线程的创建都是在栈空间，用于存储线程的私有数据，其他线程不能访问到当前线程私有的栈内存空间，保证了不同线程在处理自己的数据时，不受其他线程的影响。

**主内存（共享）**：Java内存模型总规定所有的变量都存储在主内存（共享内存），所有线程都可以访问，这就是Java的并发模型。

**线程拥有私有空间的意义** : 不同线程之间的数据互不影响。（**程序计数器，局部变量，方法参数**）

**主内存操作共享变量需要注意的事项**：

* **确定是否是多线程环境**：多线程环境下操作共享变量组要考虑线程的安全性。
* **确定是否有增删改操作**：为了保证线程的一致性，必须对该共享数据进行加锁操作。
* **多线程下的读操作**：如果只是读操作不需要进行锁操作，因为不会影响数据的准确定。

---

### 4. Java多线程的创建

**多线程的三种创建方式**

* 继承Thread类的方式创建线程；
* 实现Runnable接口；（无返回值）
* 实现Callable接口。（有返回值）

---

### 5. 多线程join方法

**jion方法的作用**

多线程环境下, 如果需要确保某一线程执行完毕之后才可以继续执行后续代码,就可以通过使用join方法完成这一需求设计。

```java
public class DemoTest{
    public static void main(String[] args) throws InterruptedException {
        Thread threadOne = new Thread(new Runnable() { //线程 1
            @Override
            public void run() {
                try {
                    Thread.sleep (5000 ); //线程 1 休眠 5 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 1 休眠 5 秒钟，执行完毕。");
            }
        });
        Thread threadTwo = new Thread(new Runnable() { //线程 2
                try {
                    Thread.sleep (10000 ); //线程 2 修眠 10 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 2 修眠 10 秒钟，执行完毕。");
            }
        });
        Thread threadThree = new Thread(new Runnable() {//线程 3
               try {
                    Thread.sleep (8000 ); //线程 3 修眠 8 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 3 修眠 8 秒钟，执行完毕。");
            }
        });
        Long startTime = System.currentTimeMillis();
        threadOne.start();
        threadTwo.start();
        threadThree.start();
        System.out.println("等待三个线程全部执行完毕再继续向下执行,我要使用 join 方法了。");
        threadOne.join(); //线程 1 调用 join 方法
        threadTwo.join(); //线程 2 调用 join 方法
        threadThree.join(); //线程 3 调用 join 方法
        Long endTime = System.currentTimeMillis();
        System.out.println("三个线程都执行完毕了，共用时： "+ (endTime - startTime) + "毫秒");
    }
}
```

**带参数的join方法的使用** `threadTwo.join(3000); //线程 2 调用 join 方法 `

意思是等待3000毫秒后终止线程等待, 加入这段时间内该线程还没执行完, 也不会继续等待。

---

### 6. 多线程yield方法

**yield方法作用**:

* 告诉线程调度器自己占有的时间片还没有是用完事务部分自己不想使用了, 主动放弃剩余时间片,并在合适的情况下,重新获取新的执行时间片。
* 放弃CPU使用权, 把CPU使用权让给跟自己优先级相同的线程或者是比自己优先级搞得线程使用, 当前线程由运行状态进入就绪状态继续排等待CPU的执行权
* **总结一句话**：让出 CPU 执行权给给与当前线程优先级相同的线程使用，进入就绪状态。

**yield代码实现**：`this.yield(); // 加入 yield 方法`

**yield方法和sleep方法的区别**:

* sleep()方法给其他线程运行时机时不会考虑线程的优先级, 因此会给低优先级的线程运行机会;
* yeild()方法只会给相同优先级或更高优先级的线程以运行机会;
* 线程执行sleep()方法后转入阻塞(blocked)状态, 而执行yeild方法后转入就绪(ready)状态;
* sleep()方法声明会抛出interruptedException,而yield()方法没有任何声明异常;
* sleep()方法比yeild()方法具有更好的移植性(跟操作系统cpu调度有关)。

---

### 7. 线程上下文切换与死锁

**线程上下文的切换**

* **是什么**: 就是当前线程使用完时间片以后，就会处于就绪状态让出CPU，让其他线程占用，就是从当前线程切换到其他线程。
* **切换时机**：就是当前线程的CPU时间片使用完或者当前线程别其他线程中断；一个线程释放，另一个线程获得，就是上下文切换时机

**死锁**

* **死锁条件** ：发生死锁时，必然存在一个线程请求资源的环形链。
* **如何避免死锁**： 破话构造自锁的条件即可，使用资源申请的有序性原则就可以避免死锁。

---

### 8.守护线程与用户线程

---

### 9. ThreadLocal的使用

---

## 二 多线程的安全与同步

### 10.多线程操作原则

### 11.多线程的状态

**操作系统线程的生命周期以及线程的5中状态**

* **创建(new)**: 初始化状态
* **就绪(Runnable)**: 已做好运行准备,随时待命
* **运行状态(Running)**: CPU正在进行核心调度
* **阻塞(Block)**: 线程锁导致的线程阻塞状态, 当两个以上线程进行非读操作时, 只允许一条线程进行操作(运行状态), 其他线程不允许进入操作(阻塞状态),
* **死亡状态(Dead)**: 线程工作结束,被操作系统回收.

**Java线程的生命周期及状态以及线程的6中状态**

>  Java线程将 "就绪状态(Runnable)" 和 "运行状态(Runnning)" 两种状态合并为 "可运行状态(Runnable)"

* **新建(New)**: 一个线程实例new出来,就进入了初始状态
* **可运行(Runnable)**: 线程正在被JVM执行或者是等待获取操作系统CPU资源
* **阻塞(Blocked)**:进入被synchronized关键字修饰的方法或代码块是,其他线程正在执行,当前线程不能进入该方法,进入阻塞状态
* **等待(Waiting)**: 当前线程执行`wait()`方法后进入等待状态(==释放线程锁, 放弃执行权限==), 如果没有显示`notify()`方法或者是`notifyAll()`方法,机会一直处于等待状态
* 超时等待(TimedWaiting)**:执行`sleep(long time)`方法后,时间一到自动唤醒线程
* **终止状态(Terminated)**: 任务执行完毕,资源被回收, 不可逆

**Java多线程状态下的锁与CPU的关系**: [参考](https://www.cnblogs.com/insanexs/p/12165685.html)

### 12.synchronized关键字

**synchroinzed关键字介绍**

* **概念**:  synchronized是Java提供的一种原子性内置锁, 
* **线程的执行**: 在代码进入synchronized代码块钱会自动获取内部锁, 这时候其他线程访问该同步代码块是会被阻塞挂起, 拿到内部锁的线程会在==正常退出同步代码块== 或者 ==抛出异常后退出== 或者 ==在同步块内调用了该内置锁资源的wait系列方法时== 释放该内置锁。
* **内置锁** : 即排他锁, 当一个线程获取这个锁之后, 其他线程必须等待该线程释放锁之后才能再获取该锁。

**synchroinzed关键字作用**

* 避免在并发编程中存在线程安全问题, 保证共享数据的一致性。

**synchroinzed关键字的三种使用方式**

* **普通同步方法**:锁是当前对象, 进入同步代码块前要获得当前实例对象的锁。  
* **静态同步方法**: 锁是当前类的class对象, 进入同步代码块前要获得当前类对象的锁
* **同步代码块**: 锁是括号里面的(**用final修饰**)对象 对给定对象加锁, 进入同步代码块前要获得给定对象的锁。

### 13.生产者与消费者案例

### 14.volatile关键字

**volatile关键介绍**

* volatile关键字解决了内存可见性的问题, 是一种弱形式的同步, 当线程写入被volatile修饰的变量时, JVM会把该值直接刷新回主内存, 而不是放在缓存中
* 当其他线程读取被volatile修饰的共享变量时, 会从主内存重新获取最新的值, 而不是使用当前线程的工作内存中的值。

**volatile与sychroinzed的区别**

* volatile本质就是告诉jvm当前变量在寄存器(工作内存)中的值还不确定, 组要从主内存中读取; 而synchroinzed则是锁定当前变量, 只有当前线程可以访问当前变量,其他线程被堵塞。
* volatile仅能使用在变量级别; sychroinzed则可以使用在变量,方法, 和类级别的;
* volatile变量仅能实现变量修改的可见性, 不能保证原子性; 而sychroinzed则可以保证变量的修改可见性和原子性;
* volatile不会造成线程的阻塞;sychroinzed可能会造成线程的阻塞;
* volatile标记的变量不会被编译器优化; sychroinzed标记的变量可以被编译器优化

**volatile关键字原理**

* **对没有被volatile关键字修饰的变量的读取方式如下图:**
* ![](http://img.mukewang.com/wiki/5efe09930935e95707000307.jpg)
* 而声明变量是volatile的, JVM保证每次读变量都从主内存中读, 跳过CPU cache。

**volatile 关键字适合的场景使用(在该场景下才能保证变量线程安全)** : [参考](https://www.jianshu.com/p/7798161d7472)

* 运算结果并不起来变量的当前值, 或者能够保证只有单一线程修改变量值
* 变量不需要与其它变量共同参与不变约束。

****

### 15.CAS操作原理

**CAS介绍**



### 16.Unsafe类方法介绍

 ### 17.Unsafe类的使用

## 三并发锁

### 18.Java多线程锁介绍

### 19.并发锁值Lock接口

### 20.乐观锁与悲观锁

### 21.AQS原理

### 22.ReentrantLock使用

### 23.锁的可重用行验证

### 24.读写锁

### 25.ReentrantReadWriteLock

### 26.锁机制之Condition接口

### 27.多线程售票案例





