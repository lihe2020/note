# 并发编程入门教程

## 一  并发编程基础

### 1. 并发编程简介

**并发编程的特征**: ① 原子性，②可见性，③有序性。

---

### 2. 操作系统的并发

**最简单的CPU核心通过缓存与主存进程进行通讯模型**

<img src="http://img.mukewang.com/wiki/5efc3cd809bf95de07000298.jpg" style="zoom:50%;" />

**操作系统给，进程，线程之间的联系和区别**

<img src="http://img.mukewang.com/wiki/5efc3cf1093ad6c707000253.jpg" style="zoom:80%;" />

**进程**：是系统进行资源分配和调度的基本单位，是操作系统结构的基础。其实就是CPU时间片的切换。（类似一个产品生产的车间）

**线程**：线程是操作系统能够进行资源调度的最小单位，他被包含在进程之中，是进程中的实际运作单位，每个线程执行的都是进程代码的某个片段，特定的线程总是在执行特定的任务。

**线程与进程的区别**：

* **诞生起源**：现有进程，后有线程。
* **概念**：进程是资源分配的最小单位，线程是程序执行的最小单位
* **内存共享**：默认情况下，进程的内存无法与其他进程共享，线程共享有操作系统跟配给其父进程的内存块。

**串行，并行与并发**

* **串行**：顺序执行，按部就班。
* **并行**：同时执行，多管齐下。
* **并发**：交替执行，减少等待。

---

### 3. Java线程内存模型

Java内存模型（即Java Memory Model，简称 JMM ，一种抽象的概念，并不是真是存在，他描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式（包括实例字段，静态字段和构成数组对象的元素）。

**Java线程的私有内存和主内存**：

<img src="http://img.mukewang.com/wiki/5efc8887097f2fbc07000226.jpg" style="zoom:80%;" />

**工作内存（私有）**：JVM运行程序的实体是线程，线程的创建都是在栈空间，用于存储线程的私有数据，其他线程不能访问到当前线程私有的栈内存空间，保证了不同线程在处理自己的数据时，不受其他线程的影响。

**主内存（共享）**：Java内存模型总规定所有的变量都存储在主内存（共享内存），所有线程都可以访问，这就是Java的并发模型。

**线程拥有私有空间的意义** : 不同线程之间的数据互不影响。（**程序计数器，局部变量，方法参数**）

**主内存操作共享变量需要注意的事项**：

* **确定是否是多线程环境**：多线程环境下操作共享变量组要考虑线程的安全性。
* **确定是否有增删改操作**：为了保证线程的一致性，必须对该共享数据进行加锁操作。
* **多线程下的读操作**：如果只是读操作不需要进行锁操作，因为不会影响数据的准确定。

---

### 4. Java多线程的创建

**多线程的三种创建方式**

* 继承Thread类的方式创建线程；
* 实现Runnable接口；（无返回值）
* 实现Callable接口。（有返回值）

---

### 5. 多线程join方法

**jion方法的作用**

多线程环境下, 如果需要确保某一线程执行完毕之后才可以继续执行后续代码,就可以通过使用join方法完成这一需求设计。

```java
public class DemoTest{
    public static void main(String[] args) throws InterruptedException {
        Thread threadOne = new Thread(new Runnable() { //线程 1
            @Override
            public void run() {
                try {
                    Thread.sleep (5000 ); //线程 1 休眠 5 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 1 休眠 5 秒钟，执行完毕。");
            }
        });
        Thread threadTwo = new Thread(new Runnable() { //线程 2
                try {
                    Thread.sleep (10000 ); //线程 2 修眠 10 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 2 修眠 10 秒钟，执行完毕。");
            }
        });
        Thread threadThree = new Thread(new Runnable() {//线程 3
               try {
                    Thread.sleep (8000 ); //线程 3 修眠 8 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 3 修眠 8 秒钟，执行完毕。");
            }
        });
        Long startTime = System.currentTimeMillis();
        threadOne.start();
        threadTwo.start();
        threadThree.start();
        System.out.println("等待三个线程全部执行完毕再继续向下执行,我要使用 join 方法了。");
        threadOne.join(); //线程 1 调用 join 方法
        threadTwo.join(); //线程 2 调用 join 方法
        threadThree.join(); //线程 3 调用 join 方法
        Long endTime = System.currentTimeMillis();
        System.out.println("三个线程都执行完毕了，共用时： "+ (endTime - startTime) + "毫秒");
    }
}
```

**带参数的join方法的使用** `threadTwo.join(3000); //线程 2 调用 join 方法 `

意思是等待3000毫秒后终止线程等待, 加入这段时间内该线程还没执行完, 也不会继续等待。

---

### 6. 多线程yield方法

**yield方法作用**:

* 告诉线程调度器自己占有的时间片还没有是用完事务部分自己不想使用了, 主动放弃剩余时间片,并在合适的情况下,重新获取新的执行时间片。
* 放弃CPU使用权, 把CPU使用权让给跟自己优先级相同的线程或者是比自己优先级搞得线程使用, 当前线程由运行状态进入就绪状态继续排等待CPU的执行权

**yield方法和sleep方法的区别**:

* sleep()方法给其他线程运行时机时不会考虑线程的优先级, 因此会给低优先级的线程运新机会;
* yeild()方法只会给相同优先级或更高优先级的线程以运行机会;
* 线程执行sleep()方法后转入阻塞(blocked)状态, 而执行yeild方法后转入就绪(ready)状态;
* sleep()方法声明会抛出interruptedException,而yield()方法没有任何声明异常;
* sleep()方法比yeild()方法具有更好的移植性(跟操作系统cpu调度有关)。

---

### 7. 线程上下文切换与死锁

---

### 8.守护线程与用户线程

---

### 9. ThreadLocal的使用

---

## 二 多线程的安全与同步





