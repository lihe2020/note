# 并发编程入门教程

## 一  并发编程基础

### 1. 并发编程简介

**并发编程的特征**: ① 原子性，②可见性，③有序性。

---

### 2. 操作系统的并发

**最简单的CPU核心通过缓存与主存进程进行通讯模型**

<img src="http://img.mukewang.com/wiki/5efc3cd809bf95de07000298.jpg" style="zoom:50%;" />

**操作系统给，进程，线程之间的联系和区别**

<img src="http://img.mukewang.com/wiki/5efc3cf1093ad6c707000253.jpg" style="zoom:80%;" />

**进程**：是系统进行资源分配和调度的基本单位，是操作系统结构的基础。其实就是CPU时间片的切换。（类似一个产品生产的车间）

**线程**：线程是操作系统能够进行资源调度的最小单位，他被包含在进程之中，是进程中的实际运作单位，每个线程执行的都是进程代码的某个片段，特定的线程总是在执行特定的任务。

**线程与进程的区别**：

* **诞生起源**：现有进程，后有线程。
* **概念**：进程是资源分配的最小单位，线程是程序执行的最小单位
* **内存共享**：默认情况下，进程的内存无法与其他进程共享，线程共享有操作系统跟配给其父进程的内存块。

**串行，并行与并发**

* **串行**：顺序执行，按部就班。
* **并行**：同时执行，多管齐下。
* **并发**：交替执行，减少等待。

---

### 3. Java线程内存模型

Java内存模型（即Java Memory Model，简称 JMM ，一种抽象的概念，并不是真是存在，他描述的是一组规则或规范，通过这组规范定义了程序中各个变量的访问方式（包括实例字段，静态字段和构成数组对象的元素）。

**Java线程的私有内存和主内存**：

<img src="http://img.mukewang.com/wiki/5efc8887097f2fbc07000226.jpg" style="zoom:80%;" />

**工作内存（私有）**：JVM运行程序的实体是线程，线程的创建都是在栈空间，用于存储线程的私有数据，其他线程不能访问到当前线程私有的栈内存空间，保证了不同线程在处理自己的数据时，不受其他线程的影响。

**主内存（共享）**：Java内存模型总规定所有的变量都存储在主内存（共享内存），所有线程都可以访问，这就是Java的并发模型。

**线程拥有私有空间的意义** : 不同线程之间的数据互不影响。（**程序计数器，局部变量，方法参数**）

**主内存操作共享变量需要注意的事项**：

* **确定是否是多线程环境**：多线程环境下操作共享变量组要考虑线程的安全性。
* **确定是否有增删改操作**：为了保证线程的一致性，必须对该共享数据进行加锁操作。
* **多线程下的读操作**：如果只是读操作不需要进行锁操作，因为不会影响数据的准确定。

---

### 4. Java多线程的创建

**多线程的三种创建方式**

* 继承Thread类的方式创建线程；
* 实现Runnable接口；（无返回值）
* 实现Callable接口。（有返回值）

---

### 5. 多线程join方法

**jion方法的作用**

多线程环境下, 如果需要确保某一线程执行完毕之后才可以继续执行后续代码,就可以通过使用join方法完成这一需求设计。

```java
public class DemoTest{
    public static void main(String[] args) throws InterruptedException {
        Thread threadOne = new Thread(new Runnable() { //线程 1
            @Override
            public void run() {
                try {
                    Thread.sleep (5000 ); //线程 1 休眠 5 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 1 休眠 5 秒钟，执行完毕。");
            }
        });
        Thread threadTwo = new Thread(new Runnable() { //线程 2
                try {
                    Thread.sleep (10000 ); //线程 2 修眠 10 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 2 修眠 10 秒钟，执行完毕。");
            }
        });
        Thread threadThree = new Thread(new Runnable() {//线程 3
               try {
                    Thread.sleep (8000 ); //线程 3 修眠 8 秒钟
                } catch (InterruptedException e) { e.printStackTrace();}
                System.out.println ("线程 3 修眠 8 秒钟，执行完毕。");
            }
        });
        Long startTime = System.currentTimeMillis();
        threadOne.start();
        threadTwo.start();
        threadThree.start();
        System.out.println("等待三个线程全部执行完毕再继续向下执行,我要使用 join 方法了。");
        threadOne.join(); //线程 1 调用 join 方法
        threadTwo.join(); //线程 2 调用 join 方法
        threadThree.join(); //线程 3 调用 join 方法
        Long endTime = System.currentTimeMillis();
        System.out.println("三个线程都执行完毕了，共用时： "+ (endTime - startTime) + "毫秒");
    }
}
```

**带参数的join方法的使用** `threadTwo.join(3000); //线程 2 调用 join 方法 `

意思是等待3000毫秒后终止线程等待, 加入这段时间内该线程还没执行完, 也不会继续等待。

---

### 6. 多线程yield方法

**yield方法作用**:

* 告诉线程调度器自己占有的时间片还没有是用完事务部分自己不想使用了, 主动放弃剩余时间片,并在合适的情况下,重新获取新的执行时间片。
* 放弃CPU使用权, 把CPU使用权让给跟自己优先级相同的线程或者是比自己优先级搞得线程使用, 当前线程由运行状态进入就绪状态继续排等待CPU的执行权
* **总结一句话**：让出 CPU 执行权给给与当前线程优先级相同的线程使用，进入就绪状态。

**yield代码实现**：`this.yield(); // 加入 yield 方法`

**yield方法和sleep方法的区别**:

* sleep()方法给其他线程运行时机时不会考虑线程的优先级, 因此会给低优先级的线程运行机会;
* yeild()方法只会给相同优先级或更高优先级的线程以运行机会;
* 线程执行sleep()方法后转入阻塞(blocked)状态, 而执行yeild方法后转入就绪(ready)状态;
* sleep()方法声明会抛出interruptedException,而yield()方法没有任何声明异常;
* sleep()方法比yeild()方法具有更好的移植性(跟操作系统cpu调度有关)。

---

### 7. 线程上下文切换与死锁

**线程上下文的切换**

* **是什么**: 就是当前线程使用完时间片以后，就会处于就绪状态让出CPU，让其他线程占用，就是从当前线程切换到其他线程。
* **切换时机**：就是当前线程的CPU时间片使用完或者当前线程别其他线程中断；一个线程释放，另一个线程获得，就是上下文切换时机

**死锁**

* **死锁条件** ：发生死锁时，必然存在一个线程请求资源的环形链。
* **如何避免死锁**： 破坏构造自锁的条件即可，使用资源申请的有序性原则就可以避免死锁。

---

### 8.守护线程与用户线程

**守护线程和用户线程的区别**：守护线程是否结束不会影响JVM的退出

**守护线程的特点**： 

* 守护线程hi运行在程序后台的线程
* 守护线程创建的线程，依然是守护线程
* 守护线程不会影响JVM的退出，当JVM值剩余守护线程时，JVM进行退出
* 守护线程在JVM退出时，自动销毁

**守护线程的创建**

* **创建细节**： 

  * thread.setDaemon(ture)必须在thread.start()之前设置，否则会抛异常
  * 不能把正在运行的常规线程设置为守护线程，
  * 在Daemon线程中产生的新的线程也是Daemnon的
  * 守护线程应该i永远不去访问固有资源，如文件，数据库，因为他在任何时候甚至在一个操作的中间发生中断

* **守护线程创建的代码示例**

*   ```java
  public class DemoTest {
      public static void main(String[] args) throws InterruptedException {
          Thread threadOne = new Thread(new Runnable() {
              @Override
              public void run() {
                  //代码执行逻辑
              }
          });
          threadOne.setDaemon(true); //设置threadOne为守护线程
          threadOne. start();
      }
  }
  ```


**守护线程的作用及使用场景**

* **作用**：为了辅助用户线程的， 用户线程都没有了，守护线程也就没有存在的必要了
* **应用场景**
  * 为其他线程提供服务支持的情况，可选守护线程
  * 当程序结束时，这个线程必须正常且立刻关闭，就可以作为守护线程来使用
  * 如果一个正在执行某个操作的线程必须要执行完毕后再释放，否则就会出现不良后果的话，那么这个线程就不能是守护线程，而只能是用户线程
  * 正常开发过程中，一般心跳监听，垃圾回收，进士数据清理等通用服务会选择守护线程

**小结**： 掌握用户线程和守护线程的区别点非常重要，在实际的工作中，对一些服务，通用型的咸亨服务科一根据需要先择守护线程进行执行，这样可以减少jvm不可退出的现象，并且可以更好地协调不同种类的线程之间的协作，减少守护线程对优先级高的用户线程资源争夺，使系统更加的稳定

---

### 9. ThreadLocal的使用

**概述**： ThreadLocal回味每个使用改变量的线程提供对立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。

**作用**：

* 当你创建一个ThreadLocal变量时，每个线程都有这个变量的副本，但国歌先传给你操作这个变量时，实际上擦做的是自己本地内存里的变量， 从而避免线程安全。

**原理**：ThreadLocal是线程本地存储，在每个线程中都创建了一个ThreadLocalMap对象，每个线程可以访问自己内部ThreadLocalMap对象内的value，通过这种方式比卖你资源在多线中间共享。

**使用场景**：如没噶线程分配一个JDBC来凝结Connection，这样既可以保证每个线程都在各自的Connection上进行数据库的操作，不会出现A线程关了B线程正在使用的Connection。还有Session管理等问题。

**ThreadLocal 的set方法**：

* 是为了设置ThreadLocal变量，设置成功后，该变量是能够被当前线程访问，其他线程不能访问

**ThreadLocal 的 get方法**：

* 是为了获取ThreadLoca变量的值，该方法没有任何入参，直接调用即可获取

**ThreadLocal 的remove方法**: 

* 是为了清除ThreadLocal的变量，清除成功后，该ThreadLocal的当前线程中没有变量值

---

## 二 多线程的安全与同步

###  10.多线程操作的原则

**多线程的AVO原则**

* **A**：即Atomic，原子性操作，对基本数据类型的变量读和谐是保证原子性操作，要么都成功，要么都失败，这些操作不可中断。
* **V**：即volatile，可见性原则，使用volatile关键字，保证了变量的可见性，到主内存拿数据，不是到缓存里拿
* **O**：即Order，就是有序性。代码的执行顺序，在代码编译前和代码编译后的执行顺序不变。

### 11.线程状态详解

### 12. synchronized关键字

### 13.生产者与消费者案例

### 14. volatile关键字





